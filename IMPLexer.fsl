{
module IMPLexer

open System
open Microsoft.FSharp.Text.Lexing

open IMPParser

let keywords =
    [
        "cobegin", COBEGIN;
        "coend", COEND;
        "skip", SKIP;
        "wait", WAIT;
        "if", IF;
        "then", THEN;
        "else", ELSE;
        "endif", ENDIF;
        "while", WHILE;
        "do", DO;
        "endwhile", ENDWHILE;
        "True", TRUE;
        "False", FALSE;
    ] |> Map.ofList

let ops =
    [
        "+",    PLUS;
        "-",    MINUS;
        "*",    TIMES;

        "=",    EQ;
        "<=",   LE;
        "!",    NOT;
        "&",    AND;
        "|",    OR;

        "||",   CO;
        ";",    SEMI;

        ":=",   ASSIGN;
        "(",    LPAREN;
        ")",    RPAREN;
    ] |> Map.ofList
}

let char    = ['a'-'z''A'-'Z']
let identifier  = char*
let digit   = ['0'-'9']
let number    = digit
let whitespace  = [' ' '\t']
let newline     = "\n\r" | '\n' | '\r'
let operator    = "+" | "-" | "*" | "=" | "<=" | "!" | "&" | "|" | "||" | ";" | ":=" | "(" | ")"

rule tokenize = parse
| whitespace    { tokenize lexbuf }
| newline       { lexbuf.EndPos <- lexbuf.EndPos.NextLine; tokenize lexbuf; }
| number        { INT(Int32.Parse(LexBuffer<_>.LexemeString lexbuf)) }
| operator      { ops.[LexBuffer<_>.LexemeString lexbuf] }
| identifier    { match keywords.TryFind(LexBuffer<_>.LexemeString lexbuf) with   
                  | Some(token) -> token   
                  | None -> NAME(LexBuffer<_>.LexemeString lexbuf) }
| eof           { EOF }
