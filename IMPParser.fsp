%{
open IMPNode
%}

%token <string> NAME
%token <int> INT


%token SEMI
%token TRUE FALSE
%token PLUS MINUS TIMES
%token EQ LE
%token AND OR NOT
%token CO COBEGIN COEND SKIP WAIT LPAREN RPAREN IF THEN ELSE ENDIF WHILE DO ENDWHILE ASSIGN
%token EOF

%right NOT
%left SEMI
%left PLUS MINUS
%left TIMES
%left OR
%left AND

// start
%start start
%type <IMPNode.Program> start

%%

start:
    c_exp EOF { { Stmt = $1 } }
a_exp:
    | INT { Int($1) }
	| NAME { Name($1) }
	| a_exp PLUS a_exp { AExpression($1, IMPNode.PLUS, $3) }
	| a_exp MINUS a_exp { AExpression($1, IMPNode.MINUS, $3) }
	| a_exp TIMES a_exp { AExpression($1, IMPNode.TIMES, $3) }
b_exp:
    | TRUE { Bool(true) }
    | FALSE { Bool(false) }
	| a_exp EQ a_exp { Compare($1, IMPNode.EQ, $3) }
	| a_exp LE a_exp { Compare($1, IMPNode.LE, $3) }
	| NOT b_exp { Negative($2) }
	| b_exp AND b_exp { Bitop($1, IMPNode.AND, $3) }
	| b_exp OR b_exp { Bitop($1, IMPNode.OR, $3) }
c_exp:
    | COBEGIN c_exp CO c_exp COEND { Co($2, $4) }
	| NAME ASSIGN a_exp { Assign($1, $3) }
    | SKIP { Skip }
	| c_exp SEMI c_exp { Sequence($1, $3) }
	| WAIT LPAREN b_exp RPAREN { Wait($3) }
	| IF b_exp THEN c_exp ELSE c_exp ENDIF { If($2, $4, $6) }
	| WHILE b_exp DO c_exp ENDWHILE { While($2, $4) }
%%
